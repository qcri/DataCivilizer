%!TEX root=../main.tex


\newcommand{\eind}{error-robust inclusion dependency\xspace}
\newcommand{\ind}{inclusion dependency\xspace}
\newcommand{\R}{\ensuremath{R}\xspace}
\renewcommand{\S}{\ensuremath{S}\xspace}
\newcommand{\X}{\ensuremath{X}\xspace}
\newcommand{\Y}{\ensuremath{Y}\xspace}
\newcommand{\RX}{\ensuremath{\R[\X]}\xspace}
\newcommand{\SY}{\ensuremath{\S[\Y]}\xspace}
\newcommand{\IND}{IND\ensuremath{(\X,\Y)}\xspace}
\newcommand{\EIND}{EIND\ensuremath{(\X,\Y)}\xspace}
\newcommand\subsetsim{\mathrel{%
  \ooalign{\raise0.3ex\hbox{$\subset$}\cr\hidewidth\raise-0.6ex\hbox{\scalebox{0.8}{$\sim$}}\hidewidth\cr}}}
\newcommand{\G}{\ensuremath{G}\xspace}
\newcommand{\E}{\ensuremath{E}\xspace}
\newcommand{\U}{\ensuremath{U}\xspace}
\newcommand{\V}{\ensuremath{V}\xspace}

\newtheorem{theorem}{Theorem}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}



\section{Data Stitching}\label{sec:stitching}

%\dong{Maybe we should move the cleanliness estimation and querying things to enhanced data stitching section?}

%\dong{I am gonna to do a more detailed survey on inclusion dependency.} 


As data in large corporations are typically scattered everywhere. To better manage and use the data, it is crucial to link them together. Given a bunch of related tables without schema information, data stitcher builds a join graph on top of them, where each node represents a table and each directed edge represents a join path between two tables with necessary information, such as primary key and foreign key. Inclusion dependency is usually used to find the functional dependency (i.e., the join path or the primary key foreign key relationship) between two tables. There are several challenges in finding inclusion dependency not well solved in existing works. First of all, data in the wild is rather dirty. To tolerate errors, we extend the traditional inclusion dependency by both key coverage and text similarity and propose the \emph{\eind} in Section~\ref{subsec:eind}. We design an efficient and scalable algorithm to find the \eind. Secondly, as new data comes to us continuously, inclusion dependency must be found incrementally, which we discuss in Section~\ref{subsec:incremental}. When the join graph is ready, the user can query the join graph explicitly or implicitly. The user can specify several attributes he is interested in, which compose a \emph{query schema}. The result should be a view contains the query schema. As there are multiple views that contain the query schema and the cost for cleaning each view is different, we discuss how to rank the views by cleanliness in Section~\ref{subsec:query}.


%1. Limit the search space

%2. Tolerate errors in includency dependency

%3. Estimate the cleanings in join path

%4. Querying the graph

%5. Incremental Includency Dependency Finding


\subsection{Error-Robust Inclusion Dependency}\label{subsec:eind}


\begin{table}
\centering
\begin{tabular}{|c|l|}\hline 
 \R & A relational table \\\hline
 \S & Another relational table \\\hline
 \X & A collection of attributes from \R \\\hline
 \Y & A collection of attributes from \S \\\hline
 \RX & The projection of \R on attributes in \X \\\hline
 \SY & The projection of \S on attributes in \Y \\\hline
 $\G=((\U,\V),\E)$  & Bigraph constructed based on \RX and \SY \\\hline
 $\delta$ & Error-ratio that can be tolerated \\\hline
\end{tabular}
\caption{Notation Table.}\label{table:notation}
\end{table}


Foreign key is one of the most important schema information in managing and using data, which is typically missing in real world. The foreign key and primary key relations are usually identified by inclusion dependency\footnote{To add reference here}. Next we briefly introduce the inclusion dependency. For ease of presentation, we first give some notations, which is shown in Table~\ref{table:notation}. We use \R and \S to denote two different relational tables (without schema information) and \X and \Y to denote two collection of attributes from \R and \S respectively. Note \X and \Y have the same cardinality, i.e., same number of attributes. \RX and \SY are respectively the projection of \R on attributes in \X and the projection of \S on attributes in \Y. There is an inclusion dependency from \X to \Y iff. $\RX\subseteq\SY$. We shall call the values in \RX \emph{dependent values} and the values in \SY \emph{referenced values}. For example, \dong{add an example here.}

However, data in the wild is full of errors, such as inconsistence and format errors. This yields to the requirement of error tolerating in inclusion dependency. We observe that the errors in data can contaminate the inclusion dependency in two ways. First, they make the corresponding dependent value and the referenced value not match exactly. Second, they make the dependent values are not all covered by the referenced values. To address these issues, we design an error-robust inclusion dependency which enhances the traditional inclusion dependency with value coverage and text similarity and utilize it to build the join graph. Next we discuss the details.


Given two projections \RX and \SY, we use the maximum bipartite matching to calculate the chance of inclusion dependency from \RX to \SY. We first build a bigraph $\G=((\U,\V),\E)$ based on the projections. Each vertex $u$ in $\U$ corresponds to an instance in \RX and each vertex $v$ in $\V$ corresponds to an instance in \SY. There is an edge between any two vertex $u\in\U$ and $v\in\V$ and the weight $w(u,v)$ is defined by the text similarity between their corresponding instance values. We utilize Jaccard similarity and edit similarity to evaluate the text similarity between two values. As it requires all the values in two instance to be similar in inclusion dependency, we combine the similarities by multiplying. \dong{To add an example here.}


%$\X\precsim\Y$  $\X\preceq\Y$

\begin{definition}[Error-Robust Inclusion Dependency]
Given two projections \RX and \SY on relational tables and an error-tolerating threshold $\delta$, there is an error-robust inclusion dependency from \X to \Y when the weight of the maximum bipartite matching in the bigraph constructed from \RX and \SY is no smaller than $\delta$.
\end{definition}

\dong{I am gonna to come up with some algorithm here later.}

\dong{scalable inclusion dependency finding algorithm that runs on distributed platform can be a future work.}

\dong{semantic matching can be another future work.}

\subsection{Find Inclusion Dependency Incrementally}\label{subsec:incremental}


As the data comes to us gradually while finding the inclusion dependency, especially the error-robust inclusion dependency, is time consuming, it is urgent to have the inclusion dependency incrementally founded. To achieve this, \dong{I will come up with some incremental algorithm here}.  



\subsection{Query the Join Graph}\label{subsec:query}

Once the join graph is constructed, the users can query it in various way. The essential way to query the join graph is taking several vertexes and find an subgraph containing all the query vertexes.

%\subsection{Cleanliness Estimation}
%finding ind in a scalable way
%column de-duplication
