%!TEX root=../main.tex


\newcommand{\eind}{error-robust inclusion dependency\xspace}
\newcommand{\ind}{inclusion dependency\xspace}
\newcommand{\R}{\ensuremath{R}\xspace}
\renewcommand{\S}{\ensuremath{S}\xspace}
\newcommand{\X}{\ensuremath{X}\xspace}
\newcommand{\Y}{\ensuremath{Y}\xspace}

\newtheorem{theorem}{Theorem}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

\section{Data Stitching}\label{sec:stitching}

%\dong{Maybe we should move the cleanliness estimation and querying things to enhanced data stitching section?}

\dong{I am gonna to do a more detailed survey on inclusion dependency.} 


As data in large corporations are typically scattered everywhere. To better manage and use the data, it is crucial to link them together. Given a bunch of related tables without schema information, data stitcher builds a join graph on top of them, where each node represents a table and each directed edge represents a join path between two tables with necessary information, such as primary key and foreign key. Inclusion dependency is usually used to find the functional dependency (i.e., the join path or the primary key foreign key relationship) between two tables. There are several challenges in finding inclusion dependency not well solved in existing works. First of all, data in the wild is rather dirty. To tolerate errors, we extend the traditional inclusion dependency by both key coverage and text similarity and propose the \emph{\eind} in Section~\ref{subsec:eind}. We design an efficient and scalable algorithm to find the \eind. Secondly, as new data comes to us continuously, inclusion dependency must be found incrementally, which we discuss in Section~\ref{subsec:incremental}. When the join graph is ready, the user can query the join graph explicitly or implicitly. The user can specify several attributes he is interested in, which compose a \emph{query schema}. The result should be a view contains the query schema. As there are multiple views that contain the query schema and the cost for cleaning each view is different, we discuss how to rank the views by cleanliness in Section~\ref{subsec:query}.


%1. Limit the search space

%2. Tolerate errors in includency dependency

%3. Estimate the cleanings in join path

%4. Querying the graph

%5. Incremental Includency Dependency Finding


\subsection{Error-Robust Inclusion Dependency}\label{subsec:eind}

Data in the wild are full of errors, such as inconsistence and format errors, and typically without schema information\footnote{To add reference here}. Finding inclusion dependency with 

\begin{definition}[Error-Robust Inclusion Dependency]
Given two relations \R and \S, there is an inclusion dependency with errors when.
\end{definition}

Given \X and \Y, the is defined as 

$$The maximal matching$$


\subsection{Find Inclusion Dependency Incrementally}\label{subsec:incremental}







\subsection{Query the Join Graph}\label{subsec:query}


%\subsection{Cleanliness Estimation}
%finding ind in a scalable way
%column de-duplication
